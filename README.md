\## Відповіді на контрольні запитання



1. Яка різниця між Git та GitHub?

Git – це система контролю версій, яка працює локально на вашому комп’ютері. Вона дозволяє відстежувати зміни в коді, створювати гілки, робити коміти.

GitHub – це хостинг для Git-репозиторіїв, тобто сервіс у хмарі, який дозволяє зберігати репозиторії онлайн, співпрацювати, робити Pull Requests, рев’ю коду та CI/CD.



2\. Що означає "розподілена" система контролю версій?

У Git кожен розробник має повну копію всього репозиторію, включаючи історію змін. Це означає, що можна працювати автономно, а синхронізація відбувається через push/pull.



3\. Яка різниця між git init та git clone?

git init – створює новий пустий Git-репозиторій у поточній папці.

git clone <url> – створює копію існуючого репозиторію з віддаленого сервера і автоматично налаштовує origin.



4\. Що таке Staging Area і навіщо вона потрібна?

Staging Area (індекс) – це проміжна область, куди додаються файли перед комітом. Вона дозволяє контролювати, які зміни потраплять у наступний коміт.



5\. Яка різниця між git add . та git add -A?

git add . – додає зміни у поточній папці та підпапках, але не видаляє файли з репозиторію, якщо вони були видалені.

git add -A – додає всі зміни включаючи видалення файлів по всьому репозиторію.



6\. Як написати гарне commit message?

Короткий заголовок до 50 символів, опціональний опис після порожнього рядка (72 символи на рядок), використовувати дієслово в теперішньому часі, наприклад: "Add login form" замість "Added login form".



7\. Як виправити останній коміт?

git commit --amend – дозволяє змінити повідомлення останнього коміту або додати пропущені файли.



8\. Що таке гілка в Git і чому вони "легковажні"?

Гілка – це вказівник на коміт. Вони легковажні, бо створення та перемикання гілок у Git дуже швидке і не займає багато ресурсів.



9\. Яка різниця між git merge та git rebase?

git merge – об’єднує дві гілки, створюючи новий коміт-злиття (merge commit).

git rebase – переносить коміти однієї гілки на вершину іншої, зберігаючи історію "чистішою", без merge commit.



10\. Що таке fast-forward merge?

Злиття без створення нового коміту, коли історія однієї гілки може просто "просунутися" вперед до останнього коміту іншої гілки.



11\. Коли виникають merge конфлікти і як їх уникнути?

Конфлікти виникають, коли зміни в одному і тому ж рядку одного файлу зроблені в двох гілках. Уникнути можна, часто пулити зміни, робити невеликі коміти, та узгоджувати зміни командою.



12\. Чому не можна робити rebase публічних комітів?

Rebase змінює історію комітів. Якщо коміти вже опубліковані, зміна історії зіпсує репозиторій іншим розробникам, які з ними працюють.



13\. Що таке origin?

origin – це псевдонім для віддаленого репозиторію, зазвичай на GitHub або іншому сервері.



14\. Яка різниця між git fetch та git pull?

git fetch – завантажує зміни з віддаленого репозиторію, але не зливає їх з вашою гілкою.

git pull – завантажує зміни і одразу робить merge у вашу поточну гілку.



15\. Що робить git push --force і чому це небезпечно?

Перезаписує віддалену гілку не зважаючи на чужі коміти. Небезпечно, бо можна втратити чужі зміни, якщо хтось вже запушив їх.



16\. Як видалити віддалену гілку?

git push origin --delete <branch\_name>



17\. Яка різниця між git reset --soft, --mixed та --hard?

--soft – повертає HEAD на інший коміт, але зберігає зміни у staging area.

--mixed (за замовчуванням) – повертає HEAD і прибирає зміни зі staging, залишаючи їх у робочій директорії.

--hard – повністю скасовує коміт та зміни у staging і робочій директорії.



18\. Яка різниця між git reset та git revert?

git reset – змінює історію комітів локально (може бути небезпечно для публічних гілок).

git revert – створює новий коміт, що скасовує попередній, без зміни історії.



19\. Як скасувати git add (видалити файл зі staging)?

git restore --staged <file>



20\. Як повернути видалений файл?

git restore <file>

Або, якщо він був закомічений:

git checkout <commit\_hash> -- <file>



21\. Що не повинно потрапляти в Git репозиторій?

Паролі, ключі, великі бінарні файли (якщо не LFS), node\_modules, конфігурації з приватними даними.



22\. Що робити якщо випадково закомітили пароль?

Видалити його з історії за допомогою git filter-branch або git filter-repo.

Скасувати коміт і змінити пароль на сервері/сервісі.



23\. HTTPS vs SSH для GitHub — що краще?

HTTPS – простіший для початку, потребує PAT або логін/пароль.

SSH – зручніший для постійної роботи, без введення пароля щоразу, більш безпечний для автоматизації.



24\. Що таке Personal Access Token і навіщо він потрібен?

Це токен для автентифікації на GitHub замість пароля. Використовується для доступу через HTTPS або API.



25\. Що таке Pull Request?

Запит на злиття однієї гілки в іншу з можливістю рев’ю коду та обговорення змін.



26\. Яка різниця між Issues та Pull Requests?

Issues – для трекінгу багів, задач, обговорень.

Pull Requests – для обговорення конкретних змін у коді перед злиттям.



27\. Що таке Fork і навіщо він потрібен?

Fork – копія чужого репозиторію у вашому акаунті GitHub. Потрібен для внесення змін у чужий проект без прямого доступу.



28\. Що таке GitHub Actions?

CI/CD система для автоматизації: тести, деплой, перевірки коду після пушу чи PR.



29\. Як часто треба робити коміти?

Часто, але логічними блоками змін. Краще 5–10 маленьких комітів ніж один великий.



30\. Скільки часу має жити feature branch?

До завершення задачі. Ідеально — короткострокові гілки, щоб уникнути конфліктів.



31\. Як організувати git workflow в команді?

Використовувати main/master для продакшну, develop для інтеграції, feature branches для задач. Pull Requests для рев’ю коду.



32\. Чи треба комітити node\_modules або інші залежності?

Ні, їх краще додавати в .gitignore, бо вони зазвичай відтворюються через package.json / package-lock.json.





